"""LLM-driven selection or creation of the best-fit extraction schema.

Flow overview:

1. Check the local memory store – if a schema already exists that matches the
   doc domain, use it (unchanged logic).
2. Otherwise run the **variant generation** process, which asks the LLM for
   multiple candidate schemas (maximalist, minimalist, balanced).
3. Let the **Schema-Referee** LLM pick the winner.
4. Persist the winning schema with per-field description & rationale.
"""

from __future__ import annotations

import json
from typing import List

# stdlib
import sys, os

# third-party / internal
from ..interfaces import Document
from ..memory import FileMemoryStore, SchemaRecord
# Core services
from ..services import schema_variants


# Additional services for critic-driven refinement
from ..services.schema_critic import run as _schema_critic_run  # noqa: E402  local import
from ..services.schema_refiner import run as _schema_refiner_run  # noqa: E402  local import

# Env flag to toggle merge referee
_USE_MERGE = bool(os.getenv("EDGAR_AI_MERGE_REFEREE"))

# ---------------------------------------------------------------------------
# Public helper
# ---------------------------------------------------------------------------


def choose_schema(doc: Document, memory: FileMemoryStore, *, verbose: bool = False) -> dict:  # noqa: D401
    """Return a schema dict appropriate for *doc*.

    If the local memory store already contains a schema that should apply, we
    still rely on the `schema_variants` referee to pick among them so the same
    selection logic is used consistently.
    """

    existing_records: List[SchemaRecord] = memory.list_schema_records()

    def _log(msg: str) -> None:  # local helper respecting verbose flag
        if verbose:
            print(f"[choose_schema] {msg}", file=sys.stderr)

    if verbose:
        os.environ["EDGAR_AI_VERBOSE"] = "1"

    # -------------------------------------------------------------------
    # 1. If no existing schema -> generate fresh variants & referee
    # -------------------------------------------------------------------
    if not existing_records:
        _log("No stored schema – generating variants (maximalist/minimalist/balanced)…")
        variants = schema_variants.generate_variants(doc)
        for i, v in enumerate(variants):
            _log(f"Variant {i}: {len(v['fields'])} fields – overview: {v.get('overview','')[:80]}…")

        # -----------------------------------------------------------------
        # 1b.  Apply Schema-Critic + Refiner to each variant **before** referee
        #      so the decision stage works with improved candidates.
        # -----------------------------------------------------------------

        refined_variants: list[dict] = []
        for idx, v in enumerate(variants):
            try:
                schema_id = f"variant_{idx}"
                critiques = _schema_critic_run(schema_id, v, doc)
                refined = _schema_refiner_run(v, critiques, doc)
                refined_variants.append(refined)
            except Exception as exc:  # noqa: BLE001 – soft-fail, keep original
                _log(f"Critic/refiner failed for variant {idx}: {exc}. Using original.")
                refined_variants.append(v)

        if _USE_MERGE:
            _log("Running merge referee…")
            winning_schema = schema_variants.merge_referee(refined_variants, doc)
            _log(f"Merge referee produced {len(winning_schema.get('fields', []))} fields")
        else:
            winner_idx, reason = schema_variants.referee(refined_variants, doc)
            _log(f"Referee selected variant {winner_idx} → {reason}")
            winning_schema = refined_variants[winner_idx]

        schema_id = f"schema_{len(existing_records) + 1}"
        memory.save_schema_record(schema_id, winning_schema, rationale="auto-generated by variant flow")
        return winning_schema

    # -------------------------------------------------------------------
    # 2. There are already stored schemas.  Feed them *plus* new variants to
    #    the referee so it can decide whether to keep using one of the former
    #    or switch to a fresh schema.
    # -------------------------------------------------------------------
    stored_schemas = [r.schema_def for r in existing_records]

    # We ask Variant-Generator for *at most* one balanced proposal so the
    # referee has a challenger if the stored ones are stale.
    _log(f"{len(existing_records)} stored schema(s) found – generating one challenger variant…")
    challenger_variants = schema_variants.generate_variants(doc, minimal_only=True)
    _log("Challenger variant created.")

    # -------------------------------------------------------------------
    # 2b. Apply critic + refiner to every candidate before referee so scores
    #     influence the outcome.
    # -------------------------------------------------------------------

    all_raw_candidates = stored_schemas + challenger_variants
    refined_candidates: list[dict] = []

    for idx, cand in enumerate(all_raw_candidates):
        try:
            schema_id = f"cand_{idx}"
            critiques = _schema_critic_run(schema_id, cand, doc)
            refined = _schema_refiner_run(cand, critiques, doc)
            refined_candidates.append(refined)
        except Exception as exc:  # noqa: BLE001
            _log(f"Critic/refiner failed for candidate {idx}: {exc}. Using original.")
            refined_candidates.append(cand)

    if _USE_MERGE:
        _log("Running merge referee with stored + challenger schemas…")
        winning_schema = schema_variants.merge_referee(refined_candidates, doc)
        reason = "merged schema"
    else:
        winner_idx, reason = schema_variants.referee(refined_candidates, doc)
        _log(
            f"Referee chose schema index {winner_idx} (new: {winner_idx >= len(stored_schemas)}) – {reason}"
        )
        winning_schema = refined_candidates[winner_idx]

        # If the winner is brand-new (i.e. came from challenger list) we persist it
        is_new = winner_idx >= len(stored_schemas)
        if is_new:
            schema_id = f"schema_{len(existing_records) + 1}"
            memory.save_schema_record(schema_id, winning_schema, rationale="promoted by referee")

    # When merge path used and schema not yet stored, persist it
    if _USE_MERGE and winning_schema not in [r.schema_def for r in existing_records]:
        schema_id = f"schema_{len(existing_records) + 1}"
        memory.save_schema_record(schema_id, winning_schema, rationale="merged by referee")

    return winning_schema
